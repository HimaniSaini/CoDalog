# Generated from CoDalog.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\17")
        buf.write("\u0082\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\3\2\3\2\7\2\37\n\2\f\2\16\2\"\13\2\7\2$\n\2\f\2")
        buf.write("\16\2\'\13\2\3\2\3\2\3\3\3\3\3\3\5\3.\n\3\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\7\3\7\3\7\3\7\3\7\7\7G\n\7\f\7\16\7J\13\7\5\7")
        buf.write("L\n\7\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\n\3\n\5\nW\n\n\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\7\13_\n\13\f\13\16\13b\13\13")
        buf.write("\5\13d\n\13\3\f\3\f\7\fh\n\f\f\f\16\fk\13\f\3\f\3\f\7")
        buf.write("\fo\n\f\f\f\16\fr\13\f\3\f\3\f\7\fv\n\f\f\f\16\fy\13\f")
        buf.write("\3\f\5\f|\n\f\3\r\3\r\3\16\3\16\3\16\2\2\17\2\4\6\b\n")
        buf.write("\f\16\20\22\24\26\30\32\2\3\4\2\4\4\r\r\2\u0081\2%\3\2")
        buf.write("\2\2\4-\3\2\2\2\6/\3\2\2\2\b\66\3\2\2\2\n;\3\2\2\2\fK")
        buf.write("\3\2\2\2\16M\3\2\2\2\20Q\3\2\2\2\22V\3\2\2\2\24c\3\2\2")
        buf.write("\2\26{\3\2\2\2\30}\3\2\2\2\32\177\3\2\2\2\34 \5\4\3\2")
        buf.write("\35\37\7\16\2\2\36\35\3\2\2\2\37\"\3\2\2\2 \36\3\2\2\2")
        buf.write(" !\3\2\2\2!$\3\2\2\2\" \3\2\2\2#\34\3\2\2\2$\'\3\2\2\2")
        buf.write("%#\3\2\2\2%&\3\2\2\2&(\3\2\2\2\'%\3\2\2\2()\7\2\2\3)\3")
        buf.write("\3\2\2\2*.\5\n\6\2+.\5\b\5\2,.\5\6\4\2-*\3\2\2\2-+\3\2")
        buf.write("\2\2-,\3\2\2\2.\5\3\2\2\2/\60\5\16\b\2\60\61\7\17\2\2")
        buf.write("\61\62\7\6\2\2\62\63\7\17\2\2\63\64\5\f\7\2\64\65\7\n")
        buf.write("\2\2\65\7\3\2\2\2\66\67\5\20\t\2\678\5\24\13\289\7\7\2")
        buf.write("\29:\7\n\2\2:\t\3\2\2\2;<\7\5\2\2<=\5\20\t\2=>\5\22\n")
        buf.write("\2>?\7\7\2\2?@\7\n\2\2@\13\3\2\2\2AL\5\16\b\2BC\5\16\b")
        buf.write("\2CD\7\t\2\2DE\5\16\b\2EG\3\2\2\2FB\3\2\2\2GJ\3\2\2\2")
        buf.write("HF\3\2\2\2HI\3\2\2\2IL\3\2\2\2JH\3\2\2\2KA\3\2\2\2KH\3")
        buf.write("\2\2\2L\r\3\2\2\2MN\5\20\t\2NO\5\26\f\2OP\7\7\2\2P\17")
        buf.write("\3\2\2\2QR\7\4\2\2RS\7\b\2\2S\21\3\2\2\2TW\5\24\13\2U")
        buf.write("W\5\26\f\2VT\3\2\2\2VU\3\2\2\2W\23\3\2\2\2Xd\5\32\16\2")
        buf.write("YZ\5\32\16\2Z[\7\t\2\2[\\\7\17\2\2\\]\5\32\16\2]_\3\2")
        buf.write("\2\2^Y\3\2\2\2_b\3\2\2\2`^\3\2\2\2`a\3\2\2\2ad\3\2\2\2")
        buf.write("b`\3\2\2\2cX\3\2\2\2c`\3\2\2\2d\25\3\2\2\2ei\5\30\r\2")
        buf.write("fh\7\17\2\2gf\3\2\2\2hk\3\2\2\2ig\3\2\2\2ij\3\2\2\2jl")
        buf.write("\3\2\2\2ki\3\2\2\2lp\7\t\2\2mo\7\17\2\2nm\3\2\2\2or\3")
        buf.write("\2\2\2pn\3\2\2\2pq\3\2\2\2qs\3\2\2\2rp\3\2\2\2st\5\30")
        buf.write("\r\2tv\3\2\2\2ue\3\2\2\2vy\3\2\2\2wu\3\2\2\2wx\3\2\2\2")
        buf.write("x|\3\2\2\2yw\3\2\2\2z|\5\30\r\2{w\3\2\2\2{z\3\2\2\2|\27")
        buf.write("\3\2\2\2}~\7\3\2\2~\31\3\2\2\2\177\u0080\t\2\2\2\u0080")
        buf.write("\33\3\2\2\2\16 %-HKV`cipw{")
        return buf.getvalue()


class CoDalogParser ( Parser ):

    grammarFileName = "CoDalog.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "'?-'", "':-'", 
                     "')'", "'('", "','", "'.'" ]

    symbolicNames = [ "<INVALID>", "UW", "LW", "GOALSIGN", "RULESIGN", "RIGHTBRAK", 
                      "LEFTBRAK", "COMMA", "PERIOD", "LC", "UC", "DIGIT", 
                      "NEWLINE", "WS" ]

    RULE_prog = 0
    RULE_clause = 1
    RULE_e_rule = 2
    RULE_fact = 3
    RULE_goal = 4
    RULE_body = 5
    RULE_predicate = 6
    RULE_atom = 7
    RULE_termList = 8
    RULE_constantList = 9
    RULE_variableList = 10
    RULE_variable = 11
    RULE_constant = 12

    ruleNames =  [ "prog", "clause", "e_rule", "fact", "goal", "body", "predicate", 
                   "atom", "termList", "constantList", "variableList", "variable", 
                   "constant" ]

    EOF = Token.EOF
    UW=1
    LW=2
    GOALSIGN=3
    RULESIGN=4
    RIGHTBRAK=5
    LEFTBRAK=6
    COMMA=7
    PERIOD=8
    LC=9
    UC=10
    DIGIT=11
    NEWLINE=12
    WS=13

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(CoDalogParser.EOF, 0)

        def clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.ClauseContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.ClauseContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.NEWLINE)
            else:
                return self.getToken(CoDalogParser.NEWLINE, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)




    def prog(self):

        localctx = CoDalogParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 35
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.LW or _la==CoDalogParser.GOALSIGN:
                self.state = 26
                self.clause()
                self.state = 30
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.NEWLINE:
                    self.state = 27
                    self.match(CoDalogParser.NEWLINE)
                    self.state = 32
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 37
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 38
            self.match(CoDalogParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def goal(self):
            return self.getTypedRuleContext(CoDalogParser.GoalContext,0)


        def fact(self):
            return self.getTypedRuleContext(CoDalogParser.FactContext,0)


        def e_rule(self):
            return self.getTypedRuleContext(CoDalogParser.E_ruleContext,0)


        def getRuleIndex(self):
            return CoDalogParser.RULE_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClause" ):
                listener.enterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClause" ):
                listener.exitClause(self)




    def clause(self):

        localctx = CoDalogParser.ClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_clause)
        try:
            self.state = 43
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 40
                self.goal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 41
                self.fact()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 42
                self.e_rule()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class E_ruleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self):
            return self.getTypedRuleContext(CoDalogParser.PredicateContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def RULESIGN(self):
            return self.getToken(CoDalogParser.RULESIGN, 0)

        def body(self):
            return self.getTypedRuleContext(CoDalogParser.BodyContext,0)


        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_e_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterE_rule" ):
                listener.enterE_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitE_rule" ):
                listener.exitE_rule(self)




    def e_rule(self):

        localctx = CoDalogParser.E_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_e_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self.predicate()
            self.state = 46
            self.match(CoDalogParser.WS)
            self.state = 47
            self.match(CoDalogParser.RULESIGN)
            self.state = 48
            self.match(CoDalogParser.WS)
            self.state = 49
            self.body()
            self.state = 50
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FactContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def constantList(self):
            return self.getTypedRuleContext(CoDalogParser.ConstantListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_fact

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFact" ):
                listener.enterFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFact" ):
                listener.exitFact(self)




    def fact(self):

        localctx = CoDalogParser.FactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_fact)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.atom()
            self.state = 53
            self.constantList()
            self.state = 54
            self.match(CoDalogParser.RIGHTBRAK)
            self.state = 55
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GoalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GOALSIGN(self):
            return self.getToken(CoDalogParser.GOALSIGN, 0)

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def termList(self):
            return self.getTypedRuleContext(CoDalogParser.TermListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_goal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoal" ):
                listener.enterGoal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoal" ):
                listener.exitGoal(self)




    def goal(self):

        localctx = CoDalogParser.GoalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_goal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 57
            self.match(CoDalogParser.GOALSIGN)
            self.state = 58
            self.atom()
            self.state = 59
            self.termList()
            self.state = 60
            self.match(CoDalogParser.RIGHTBRAK)
            self.state = 61
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.PredicateContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.PredicateContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBody" ):
                listener.enterBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBody" ):
                listener.exitBody(self)




    def body(self):

        localctx = CoDalogParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.state = 73
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 63
                self.predicate()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 70
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.LW:
                    self.state = 64
                    self.predicate()
                    self.state = 65
                    self.match(CoDalogParser.COMMA)
                    self.state = 66
                    self.predicate()
                    self.state = 72
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def variableList(self):
            return self.getTypedRuleContext(CoDalogParser.VariableListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)




    def predicate(self):

        localctx = CoDalogParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 75
            self.atom()
            self.state = 76
            self.variableList()
            self.state = 77
            self.match(CoDalogParser.RIGHTBRAK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LW(self):
            return self.getToken(CoDalogParser.LW, 0)

        def LEFTBRAK(self):
            return self.getToken(CoDalogParser.LEFTBRAK, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)




    def atom(self):

        localctx = CoDalogParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_atom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(CoDalogParser.LW)
            self.state = 80
            self.match(CoDalogParser.LEFTBRAK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constantList(self):
            return self.getTypedRuleContext(CoDalogParser.ConstantListContext,0)


        def variableList(self):
            return self.getTypedRuleContext(CoDalogParser.VariableListContext,0)


        def getRuleIndex(self):
            return CoDalogParser.RULE_termList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermList" ):
                listener.enterTermList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermList" ):
                listener.exitTermList(self)




    def termList(self):

        localctx = CoDalogParser.TermListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_termList)
        try:
            self.state = 84
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 82
                self.constantList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 83
                self.variableList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.ConstantContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.ConstantContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_constantList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantList" ):
                listener.enterConstantList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantList" ):
                listener.exitConstantList(self)




    def constantList(self):

        localctx = CoDalogParser.ConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_constantList)
        self._la = 0 # Token type
        try:
            self.state = 97
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 86
                self.constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 94
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.LW or _la==CoDalogParser.DIGIT:
                    self.state = 87
                    self.constant()
                    self.state = 88
                    self.match(CoDalogParser.COMMA)
                    self.state = 89
                    self.match(CoDalogParser.WS)
                    self.state = 90
                    self.constant()
                    self.state = 96
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.VariableContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.VariableContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_variableList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableList" ):
                listener.enterVariableList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableList" ):
                listener.exitVariableList(self)




    def variableList(self):

        localctx = CoDalogParser.VariableListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variableList)
        self._la = 0 # Token type
        try:
            self.state = 121
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 117
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.UW:
                    self.state = 99
                    self.variable()
                    self.state = 103
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 100
                        self.match(CoDalogParser.WS)
                        self.state = 105
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 106
                    self.match(CoDalogParser.COMMA)
                    self.state = 110
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 107
                        self.match(CoDalogParser.WS)
                        self.state = 112
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 113
                    self.variable()
                    self.state = 119
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 120
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UW(self):
            return self.getToken(CoDalogParser.UW, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)




    def variable(self):

        localctx = CoDalogParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(CoDalogParser.UW)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LW(self):
            return self.getToken(CoDalogParser.LW, 0)

        def DIGIT(self):
            return self.getToken(CoDalogParser.DIGIT, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = CoDalogParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            _la = self._input.LA(1)
            if not(_la==CoDalogParser.LW or _la==CoDalogParser.DIGIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





