# Generated from CoDalog.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\17")
        buf.write("\u00ab\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\3\2\3\2\7\2\37\n\2\f\2\16\2\"\13\2\7\2$\n\2\f\2")
        buf.write("\16\2\'\13\2\3\2\3\2\3\3\3\3\3\3\5\3.\n\3\3\4\3\4\7\4")
        buf.write("\62\n\4\f\4\16\4\65\13\4\3\4\3\4\7\49\n\4\f\4\16\4<\13")
        buf.write("\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\3\7\3\7\3\7\7\7O\n\7\f\7\16\7R\13\7\3\7\3\7\7\7V")
        buf.write("\n\7\f\7\16\7Y\13\7\3\7\3\7\7\7]\n\7\f\7\16\7`\13\7\5")
        buf.write("\7b\n\7\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\n\3\n\5\nm\n\n\3")
        buf.write("\13\3\13\3\13\7\13r\n\13\f\13\16\13u\13\13\3\13\3\13\7")
        buf.write("\13y\n\13\f\13\16\13|\13\13\3\13\7\13\177\n\13\f\13\16")
        buf.write("\13\u0082\13\13\7\13\u0084\n\13\f\13\16\13\u0087\13\13")
        buf.write("\5\13\u0089\n\13\3\f\3\f\7\f\u008d\n\f\f\f\16\f\u0090")
        buf.write("\13\f\3\f\3\f\7\f\u0094\n\f\f\f\16\f\u0097\13\f\3\f\7")
        buf.write("\f\u009a\n\f\f\f\16\f\u009d\13\f\7\f\u009f\n\f\f\f\16")
        buf.write("\f\u00a2\13\f\3\f\5\f\u00a5\n\f\3\r\3\r\3\16\3\16\3\16")
        buf.write("\2\2\17\2\4\6\b\n\f\16\20\22\24\26\30\32\2\3\4\2\4\4\r")
        buf.write("\r\2\u00b2\2%\3\2\2\2\4-\3\2\2\2\6/\3\2\2\2\b@\3\2\2\2")
        buf.write("\nE\3\2\2\2\fa\3\2\2\2\16c\3\2\2\2\20g\3\2\2\2\22l\3\2")
        buf.write("\2\2\24\u0088\3\2\2\2\26\u00a4\3\2\2\2\30\u00a6\3\2\2")
        buf.write("\2\32\u00a8\3\2\2\2\34 \5\4\3\2\35\37\7\16\2\2\36\35\3")
        buf.write("\2\2\2\37\"\3\2\2\2 \36\3\2\2\2 !\3\2\2\2!$\3\2\2\2\"")
        buf.write(" \3\2\2\2#\34\3\2\2\2$\'\3\2\2\2%#\3\2\2\2%&\3\2\2\2&")
        buf.write("(\3\2\2\2\'%\3\2\2\2()\7\2\2\3)\3\3\2\2\2*.\5\n\6\2+.")
        buf.write("\5\b\5\2,.\5\6\4\2-*\3\2\2\2-+\3\2\2\2-,\3\2\2\2.\5\3")
        buf.write("\2\2\2/\63\5\16\b\2\60\62\7\17\2\2\61\60\3\2\2\2\62\65")
        buf.write("\3\2\2\2\63\61\3\2\2\2\63\64\3\2\2\2\64\66\3\2\2\2\65")
        buf.write("\63\3\2\2\2\66:\7\6\2\2\679\7\17\2\28\67\3\2\2\29<\3\2")
        buf.write("\2\2:8\3\2\2\2:;\3\2\2\2;=\3\2\2\2<:\3\2\2\2=>\5\f\7\2")
        buf.write(">?\7\n\2\2?\7\3\2\2\2@A\5\20\t\2AB\5\24\13\2BC\7\7\2\2")
        buf.write("CD\7\n\2\2D\t\3\2\2\2EF\7\5\2\2FG\5\20\t\2GH\5\22\n\2")
        buf.write("HI\7\7\2\2IJ\7\n\2\2J\13\3\2\2\2Kb\5\16\b\2LP\5\16\b\2")
        buf.write("MO\7\17\2\2NM\3\2\2\2OR\3\2\2\2PN\3\2\2\2PQ\3\2\2\2QS")
        buf.write("\3\2\2\2RP\3\2\2\2SW\7\t\2\2TV\7\17\2\2UT\3\2\2\2VY\3")
        buf.write("\2\2\2WU\3\2\2\2WX\3\2\2\2XZ\3\2\2\2YW\3\2\2\2Z[\5\16")
        buf.write("\b\2[]\3\2\2\2\\L\3\2\2\2]`\3\2\2\2^\\\3\2\2\2^_\3\2\2")
        buf.write("\2_b\3\2\2\2`^\3\2\2\2aK\3\2\2\2a^\3\2\2\2b\r\3\2\2\2")
        buf.write("cd\5\20\t\2de\5\26\f\2ef\7\7\2\2f\17\3\2\2\2gh\7\4\2\2")
        buf.write("hi\7\b\2\2i\21\3\2\2\2jm\5\24\13\2km\5\26\f\2lj\3\2\2")
        buf.write("\2lk\3\2\2\2m\23\3\2\2\2n\u0089\5\32\16\2os\5\32\16\2")
        buf.write("pr\7\17\2\2qp\3\2\2\2ru\3\2\2\2sq\3\2\2\2st\3\2\2\2t\u0080")
        buf.write("\3\2\2\2us\3\2\2\2vz\7\t\2\2wy\7\17\2\2xw\3\2\2\2y|\3")
        buf.write("\2\2\2zx\3\2\2\2z{\3\2\2\2{}\3\2\2\2|z\3\2\2\2}\177\5")
        buf.write("\32\16\2~v\3\2\2\2\177\u0082\3\2\2\2\u0080~\3\2\2\2\u0080")
        buf.write("\u0081\3\2\2\2\u0081\u0084\3\2\2\2\u0082\u0080\3\2\2\2")
        buf.write("\u0083o\3\2\2\2\u0084\u0087\3\2\2\2\u0085\u0083\3\2\2")
        buf.write("\2\u0085\u0086\3\2\2\2\u0086\u0089\3\2\2\2\u0087\u0085")
        buf.write("\3\2\2\2\u0088n\3\2\2\2\u0088\u0085\3\2\2\2\u0089\25\3")
        buf.write("\2\2\2\u008a\u008e\5\30\r\2\u008b\u008d\7\17\2\2\u008c")
        buf.write("\u008b\3\2\2\2\u008d\u0090\3\2\2\2\u008e\u008c\3\2\2\2")
        buf.write("\u008e\u008f\3\2\2\2\u008f\u009b\3\2\2\2\u0090\u008e\3")
        buf.write("\2\2\2\u0091\u0095\7\t\2\2\u0092\u0094\7\17\2\2\u0093")
        buf.write("\u0092\3\2\2\2\u0094\u0097\3\2\2\2\u0095\u0093\3\2\2\2")
        buf.write("\u0095\u0096\3\2\2\2\u0096\u0098\3\2\2\2\u0097\u0095\3")
        buf.write("\2\2\2\u0098\u009a\5\30\r\2\u0099\u0091\3\2\2\2\u009a")
        buf.write("\u009d\3\2\2\2\u009b\u0099\3\2\2\2\u009b\u009c\3\2\2\2")
        buf.write("\u009c\u009f\3\2\2\2\u009d\u009b\3\2\2\2\u009e\u008a\3")
        buf.write("\2\2\2\u009f\u00a2\3\2\2\2\u00a0\u009e\3\2\2\2\u00a0\u00a1")
        buf.write("\3\2\2\2\u00a1\u00a5\3\2\2\2\u00a2\u00a0\3\2\2\2\u00a3")
        buf.write("\u00a5\5\30\r\2\u00a4\u00a0\3\2\2\2\u00a4\u00a3\3\2\2")
        buf.write("\2\u00a5\27\3\2\2\2\u00a6\u00a7\7\3\2\2\u00a7\31\3\2\2")
        buf.write("\2\u00a8\u00a9\t\2\2\2\u00a9\33\3\2\2\2\26 %-\63:PW^a")
        buf.write("lsz\u0080\u0085\u0088\u008e\u0095\u009b\u00a0\u00a4")
        return buf.getvalue()


class CoDalogParser ( Parser ):

    grammarFileName = "CoDalog.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "'?-'", "':-'", 
                     "')'", "'('", "','", "'.'" ]

    symbolicNames = [ "<INVALID>", "UW", "LW", "GOALSIGN", "RULESIGN", "RIGHTBRAK", 
                      "LEFTBRAK", "COMMA", "PERIOD", "LC", "UC", "DIGIT", 
                      "NEWLINE", "WS" ]

    RULE_prog = 0
    RULE_clause = 1
    RULE_e_rule = 2
    RULE_fact = 3
    RULE_goal = 4
    RULE_body = 5
    RULE_predicate = 6
    RULE_atom = 7
    RULE_termList = 8
    RULE_constantList = 9
    RULE_variableList = 10
    RULE_variable = 11
    RULE_constant = 12

    ruleNames =  [ "prog", "clause", "e_rule", "fact", "goal", "body", "predicate", 
                   "atom", "termList", "constantList", "variableList", "variable", 
                   "constant" ]

    EOF = Token.EOF
    UW=1
    LW=2
    GOALSIGN=3
    RULESIGN=4
    RIGHTBRAK=5
    LEFTBRAK=6
    COMMA=7
    PERIOD=8
    LC=9
    UC=10
    DIGIT=11
    NEWLINE=12
    WS=13

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(CoDalogParser.EOF, 0)

        def clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.ClauseContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.ClauseContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.NEWLINE)
            else:
                return self.getToken(CoDalogParser.NEWLINE, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)




    def prog(self):

        localctx = CoDalogParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 35
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.LW or _la==CoDalogParser.GOALSIGN:
                self.state = 26
                self.clause()
                self.state = 30
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.NEWLINE:
                    self.state = 27
                    self.match(CoDalogParser.NEWLINE)
                    self.state = 32
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 37
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 38
            self.match(CoDalogParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def goal(self):
            return self.getTypedRuleContext(CoDalogParser.GoalContext,0)


        def fact(self):
            return self.getTypedRuleContext(CoDalogParser.FactContext,0)


        def e_rule(self):
            return self.getTypedRuleContext(CoDalogParser.E_ruleContext,0)


        def getRuleIndex(self):
            return CoDalogParser.RULE_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClause" ):
                listener.enterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClause" ):
                listener.exitClause(self)




    def clause(self):

        localctx = CoDalogParser.ClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_clause)
        try:
            self.state = 43
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 40
                self.goal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 41
                self.fact()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 42
                self.e_rule()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class E_ruleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self):
            return self.getTypedRuleContext(CoDalogParser.PredicateContext,0)


        def RULESIGN(self):
            return self.getToken(CoDalogParser.RULESIGN, 0)

        def body(self):
            return self.getTypedRuleContext(CoDalogParser.BodyContext,0)


        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_e_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterE_rule" ):
                listener.enterE_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitE_rule" ):
                listener.exitE_rule(self)




    def e_rule(self):

        localctx = CoDalogParser.E_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_e_rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self.predicate()
            self.state = 49
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.WS:
                self.state = 46
                self.match(CoDalogParser.WS)
                self.state = 51
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 52
            self.match(CoDalogParser.RULESIGN)
            self.state = 56
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.WS:
                self.state = 53
                self.match(CoDalogParser.WS)
                self.state = 58
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 59
            self.body()
            self.state = 60
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FactContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def constantList(self):
            return self.getTypedRuleContext(CoDalogParser.ConstantListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_fact

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFact" ):
                listener.enterFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFact" ):
                listener.exitFact(self)




    def fact(self):

        localctx = CoDalogParser.FactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_fact)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.atom()
            self.state = 63
            self.constantList()
            self.state = 64
            self.match(CoDalogParser.RIGHTBRAK)
            self.state = 65
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GoalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GOALSIGN(self):
            return self.getToken(CoDalogParser.GOALSIGN, 0)

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def termList(self):
            return self.getTypedRuleContext(CoDalogParser.TermListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_goal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoal" ):
                listener.enterGoal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoal" ):
                listener.exitGoal(self)




    def goal(self):

        localctx = CoDalogParser.GoalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_goal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.match(CoDalogParser.GOALSIGN)
            self.state = 68
            self.atom()
            self.state = 69
            self.termList()
            self.state = 70
            self.match(CoDalogParser.RIGHTBRAK)
            self.state = 71
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.PredicateContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.PredicateContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBody" ):
                listener.enterBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBody" ):
                listener.exitBody(self)




    def body(self):

        localctx = CoDalogParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.state = 95
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 73
                self.predicate()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 92
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.LW:
                    self.state = 74
                    self.predicate()
                    self.state = 78
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 75
                        self.match(CoDalogParser.WS)
                        self.state = 80
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 81
                    self.match(CoDalogParser.COMMA)
                    self.state = 85
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 82
                        self.match(CoDalogParser.WS)
                        self.state = 87
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 88
                    self.predicate()
                    self.state = 94
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def variableList(self):
            return self.getTypedRuleContext(CoDalogParser.VariableListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)




    def predicate(self):

        localctx = CoDalogParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.atom()
            self.state = 98
            self.variableList()
            self.state = 99
            self.match(CoDalogParser.RIGHTBRAK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LW(self):
            return self.getToken(CoDalogParser.LW, 0)

        def LEFTBRAK(self):
            return self.getToken(CoDalogParser.LEFTBRAK, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)




    def atom(self):

        localctx = CoDalogParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_atom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(CoDalogParser.LW)
            self.state = 102
            self.match(CoDalogParser.LEFTBRAK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constantList(self):
            return self.getTypedRuleContext(CoDalogParser.ConstantListContext,0)


        def variableList(self):
            return self.getTypedRuleContext(CoDalogParser.VariableListContext,0)


        def getRuleIndex(self):
            return CoDalogParser.RULE_termList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermList" ):
                listener.enterTermList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermList" ):
                listener.exitTermList(self)




    def termList(self):

        localctx = CoDalogParser.TermListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_termList)
        try:
            self.state = 106
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 104
                self.constantList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 105
                self.variableList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.ConstantContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.ConstantContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_constantList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantList" ):
                listener.enterConstantList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantList" ):
                listener.exitConstantList(self)




    def constantList(self):

        localctx = CoDalogParser.ConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_constantList)
        self._la = 0 # Token type
        try:
            self.state = 134
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 108
                self.constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 131
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.LW or _la==CoDalogParser.DIGIT:
                    self.state = 109
                    self.constant()
                    self.state = 113
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 110
                        self.match(CoDalogParser.WS)
                        self.state = 115
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 126
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.COMMA:
                        self.state = 116
                        self.match(CoDalogParser.COMMA)
                        self.state = 120
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==CoDalogParser.WS:
                            self.state = 117
                            self.match(CoDalogParser.WS)
                            self.state = 122
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 123
                        self.constant()
                        self.state = 128
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 133
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.VariableContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.VariableContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_variableList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableList" ):
                listener.enterVariableList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableList" ):
                listener.exitVariableList(self)




    def variableList(self):

        localctx = CoDalogParser.VariableListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variableList)
        self._la = 0 # Token type
        try:
            self.state = 162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 158
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.UW:
                    self.state = 136
                    self.variable()
                    self.state = 140
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 137
                        self.match(CoDalogParser.WS)
                        self.state = 142
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 153
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.COMMA:
                        self.state = 143
                        self.match(CoDalogParser.COMMA)
                        self.state = 147
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==CoDalogParser.WS:
                            self.state = 144
                            self.match(CoDalogParser.WS)
                            self.state = 149
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 150
                        self.variable()
                        self.state = 155
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 160
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 161
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UW(self):
            return self.getToken(CoDalogParser.UW, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)




    def variable(self):

        localctx = CoDalogParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(CoDalogParser.UW)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LW(self):
            return self.getToken(CoDalogParser.LW, 0)

        def DIGIT(self):
            return self.getToken(CoDalogParser.DIGIT, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = CoDalogParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            _la = self._input.LA(1)
            if not(_la==CoDalogParser.LW or _la==CoDalogParser.DIGIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





