# Generated from CoDalog.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\25")
        buf.write("\u00fd\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\3\2\3\2\7\2%\n\2\f")
        buf.write("\2\16\2(\13\2\6\2*\n\2\r\2\16\2+\3\3\3\3\3\3\5\3\61\n")
        buf.write("\3\3\4\3\4\7\4\65\n\4\f\4\16\48\13\4\3\4\3\4\7\4<\n\4")
        buf.write("\f\4\16\4?\13\4\3\4\3\4\7\4C\n\4\f\4\16\4F\13\4\3\4\3")
        buf.write("\4\7\4J\n\4\f\4\16\4M\13\4\3\4\3\4\7\4Q\n\4\f\4\16\4T")
        buf.write("\13\4\3\4\3\4\7\4X\n\4\f\4\16\4[\13\4\3\4\7\4^\n\4\f\4")
        buf.write("\16\4a\13\4\7\4c\n\4\f\4\16\4f\13\4\3\4\7\4i\n\4\f\4\16")
        buf.write("\4l\13\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\7\3\7\3\7\7\7~\n\7\f\7\16\7\u0081\13\7\3\7\3")
        buf.write("\7\7\7\u0085\n\7\f\7\16\7\u0088\13\7\3\7\3\7\7\7\u008c")
        buf.write("\n\7\f\7\16\7\u008f\13\7\5\7\u0091\n\7\3\b\3\b\3\b\3\b")
        buf.write("\3\t\3\t\3\t\3\n\3\n\7\n\u009c\n\n\f\n\16\n\u009f\13\n")
        buf.write("\3\n\3\n\7\n\u00a3\n\n\f\n\16\n\u00a6\13\n\3\n\3\n\3\13")
        buf.write("\3\13\3\13\7\13\u00ad\n\13\f\13\16\13\u00b0\13\13\3\13")
        buf.write("\3\13\7\13\u00b4\n\13\f\13\16\13\u00b7\13\13\3\13\7\13")
        buf.write("\u00ba\n\13\f\13\16\13\u00bd\13\13\7\13\u00bf\n\13\f\13")
        buf.write("\16\13\u00c2\13\13\5\13\u00c4\n\13\3\f\3\f\3\f\3\f\3\f")
        buf.write("\7\f\u00cb\n\f\f\f\16\f\u00ce\13\f\7\f\u00d0\n\f\f\f\16")
        buf.write("\f\u00d3\13\f\5\f\u00d5\n\f\3\r\3\r\7\r\u00d9\n\r\f\r")
        buf.write("\16\r\u00dc\13\r\3\r\3\r\7\r\u00e0\n\r\f\r\16\r\u00e3")
        buf.write("\13\r\3\r\7\r\u00e6\n\r\f\r\16\r\u00e9\13\r\7\r\u00eb")
        buf.write("\n\r\f\r\16\r\u00ee\13\r\3\r\5\r\u00f1\n\r\3\16\3\16\5")
        buf.write("\16\u00f5\n\16\3\17\3\17\3\20\3\20\3\21\3\21\3\21\2\2")
        buf.write("\22\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \2\4\4\2\n")
        buf.write("\n\23\23\3\2\3\b\2\u010d\2)\3\2\2\2\4\60\3\2\2\2\6\62")
        buf.write("\3\2\2\2\bo\3\2\2\2\nt\3\2\2\2\f\u0090\3\2\2\2\16\u0092")
        buf.write("\3\2\2\2\20\u0096\3\2\2\2\22\u0099\3\2\2\2\24\u00c3\3")
        buf.write("\2\2\2\26\u00d4\3\2\2\2\30\u00f0\3\2\2\2\32\u00f4\3\2")
        buf.write("\2\2\34\u00f6\3\2\2\2\36\u00f8\3\2\2\2 \u00fa\3\2\2\2")
        buf.write("\"&\5\4\3\2#%\7\24\2\2$#\3\2\2\2%(\3\2\2\2&$\3\2\2\2&")
        buf.write("\'\3\2\2\2\'*\3\2\2\2(&\3\2\2\2)\"\3\2\2\2*+\3\2\2\2+")
        buf.write(")\3\2\2\2+,\3\2\2\2,\3\3\2\2\2-\61\5\n\6\2.\61\5\b\5\2")
        buf.write("/\61\5\6\4\2\60-\3\2\2\2\60.\3\2\2\2\60/\3\2\2\2\61\5")
        buf.write("\3\2\2\2\62\66\5\16\b\2\63\65\7\25\2\2\64\63\3\2\2\2\65")
        buf.write("8\3\2\2\2\66\64\3\2\2\2\66\67\3\2\2\2\679\3\2\2\28\66")
        buf.write("\3\2\2\29=\7\f\2\2:<\7\25\2\2;:\3\2\2\2<?\3\2\2\2=;\3")
        buf.write("\2\2\2=>\3\2\2\2>@\3\2\2\2?=\3\2\2\2@D\5\f\7\2AC\7\25")
        buf.write("\2\2BA\3\2\2\2CF\3\2\2\2DB\3\2\2\2DE\3\2\2\2Ed\3\2\2\2")
        buf.write("FD\3\2\2\2GK\7\17\2\2HJ\7\25\2\2IH\3\2\2\2JM\3\2\2\2K")
        buf.write("I\3\2\2\2KL\3\2\2\2LN\3\2\2\2MK\3\2\2\2NR\5\22\n\2OQ\7")
        buf.write("\25\2\2PO\3\2\2\2QT\3\2\2\2RP\3\2\2\2RS\3\2\2\2S_\3\2")
        buf.write("\2\2TR\3\2\2\2UY\7\17\2\2VX\7\25\2\2WV\3\2\2\2X[\3\2\2")
        buf.write("\2YW\3\2\2\2YZ\3\2\2\2Z\\\3\2\2\2[Y\3\2\2\2\\^\5\22\n")
        buf.write("\2]U\3\2\2\2^a\3\2\2\2_]\3\2\2\2_`\3\2\2\2`c\3\2\2\2a")
        buf.write("_\3\2\2\2bG\3\2\2\2cf\3\2\2\2db\3\2\2\2de\3\2\2\2ej\3")
        buf.write("\2\2\2fd\3\2\2\2gi\7\25\2\2hg\3\2\2\2il\3\2\2\2jh\3\2")
        buf.write("\2\2jk\3\2\2\2km\3\2\2\2lj\3\2\2\2mn\7\20\2\2n\7\3\2\2")
        buf.write("\2op\5\20\t\2pq\5\26\f\2qr\7\r\2\2rs\7\20\2\2s\t\3\2\2")
        buf.write("\2tu\7\13\2\2uv\5\20\t\2vw\5\24\13\2wx\7\r\2\2xy\7\20")
        buf.write("\2\2y\13\3\2\2\2z\u0091\5\16\b\2{\177\5\16\b\2|~\7\25")
        buf.write("\2\2}|\3\2\2\2~\u0081\3\2\2\2\177}\3\2\2\2\177\u0080\3")
        buf.write("\2\2\2\u0080\u0082\3\2\2\2\u0081\177\3\2\2\2\u0082\u0086")
        buf.write("\7\17\2\2\u0083\u0085\7\25\2\2\u0084\u0083\3\2\2\2\u0085")
        buf.write("\u0088\3\2\2\2\u0086\u0084\3\2\2\2\u0086\u0087\3\2\2\2")
        buf.write("\u0087\u0089\3\2\2\2\u0088\u0086\3\2\2\2\u0089\u008a\5")
        buf.write("\16\b\2\u008a\u008c\3\2\2\2\u008b{\3\2\2\2\u008c\u008f")
        buf.write("\3\2\2\2\u008d\u008b\3\2\2\2\u008d\u008e\3\2\2\2\u008e")
        buf.write("\u0091\3\2\2\2\u008f\u008d\3\2\2\2\u0090z\3\2\2\2\u0090")
        buf.write("\u008d\3\2\2\2\u0091\r\3\2\2\2\u0092\u0093\5\20\t\2\u0093")
        buf.write("\u0094\5\30\r\2\u0094\u0095\7\r\2\2\u0095\17\3\2\2\2\u0096")
        buf.write("\u0097\7\n\2\2\u0097\u0098\7\16\2\2\u0098\21\3\2\2\2\u0099")
        buf.write("\u009d\5\34\17\2\u009a\u009c\7\25\2\2\u009b\u009a\3\2")
        buf.write("\2\2\u009c\u009f\3\2\2\2\u009d\u009b\3\2\2\2\u009d\u009e")
        buf.write("\3\2\2\2\u009e\u00a0\3\2\2\2\u009f\u009d\3\2\2\2\u00a0")
        buf.write("\u00a4\5 \21\2\u00a1\u00a3\7\25\2\2\u00a2\u00a1\3\2\2")
        buf.write("\2\u00a3\u00a6\3\2\2\2\u00a4\u00a2\3\2\2\2\u00a4\u00a5")
        buf.write("\3\2\2\2\u00a5\u00a7\3\2\2\2\u00a6\u00a4\3\2\2\2\u00a7")
        buf.write("\u00a8\5\32\16\2\u00a8\23\3\2\2\2\u00a9\u00c4\5\32\16")
        buf.write("\2\u00aa\u00ae\5\32\16\2\u00ab\u00ad\7\25\2\2\u00ac\u00ab")
        buf.write("\3\2\2\2\u00ad\u00b0\3\2\2\2\u00ae\u00ac\3\2\2\2\u00ae")
        buf.write("\u00af\3\2\2\2\u00af\u00bb\3\2\2\2\u00b0\u00ae\3\2\2\2")
        buf.write("\u00b1\u00b5\7\17\2\2\u00b2\u00b4\7\25\2\2\u00b3\u00b2")
        buf.write("\3\2\2\2\u00b4\u00b7\3\2\2\2\u00b5\u00b3\3\2\2\2\u00b5")
        buf.write("\u00b6\3\2\2\2\u00b6\u00b8\3\2\2\2\u00b7\u00b5\3\2\2\2")
        buf.write("\u00b8\u00ba\5\32\16\2\u00b9\u00b1\3\2\2\2\u00ba\u00bd")
        buf.write("\3\2\2\2\u00bb\u00b9\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc")
        buf.write("\u00bf\3\2\2\2\u00bd\u00bb\3\2\2\2\u00be\u00aa\3\2\2\2")
        buf.write("\u00bf\u00c2\3\2\2\2\u00c0\u00be\3\2\2\2\u00c0\u00c1\3")
        buf.write("\2\2\2\u00c1\u00c4\3\2\2\2\u00c2\u00c0\3\2\2\2\u00c3\u00a9")
        buf.write("\3\2\2\2\u00c3\u00c0\3\2\2\2\u00c4\25\3\2\2\2\u00c5\u00d5")
        buf.write("\5\36\20\2\u00c6\u00cc\5\36\20\2\u00c7\u00c8\7\17\2\2")
        buf.write("\u00c8\u00c9\7\25\2\2\u00c9\u00cb\5\36\20\2\u00ca\u00c7")
        buf.write("\3\2\2\2\u00cb\u00ce\3\2\2\2\u00cc\u00ca\3\2\2\2\u00cc")
        buf.write("\u00cd\3\2\2\2\u00cd\u00d0\3\2\2\2\u00ce\u00cc\3\2\2\2")
        buf.write("\u00cf\u00c6\3\2\2\2\u00d0\u00d3\3\2\2\2\u00d1\u00cf\3")
        buf.write("\2\2\2\u00d1\u00d2\3\2\2\2\u00d2\u00d5\3\2\2\2\u00d3\u00d1")
        buf.write("\3\2\2\2\u00d4\u00c5\3\2\2\2\u00d4\u00d1\3\2\2\2\u00d5")
        buf.write("\27\3\2\2\2\u00d6\u00da\5\34\17\2\u00d7\u00d9\7\25\2\2")
        buf.write("\u00d8\u00d7\3\2\2\2\u00d9\u00dc\3\2\2\2\u00da\u00d8\3")
        buf.write("\2\2\2\u00da\u00db\3\2\2\2\u00db\u00e7\3\2\2\2\u00dc\u00da")
        buf.write("\3\2\2\2\u00dd\u00e1\7\17\2\2\u00de\u00e0\7\25\2\2\u00df")
        buf.write("\u00de\3\2\2\2\u00e0\u00e3\3\2\2\2\u00e1\u00df\3\2\2\2")
        buf.write("\u00e1\u00e2\3\2\2\2\u00e2\u00e4\3\2\2\2\u00e3\u00e1\3")
        buf.write("\2\2\2\u00e4\u00e6\5\34\17\2\u00e5\u00dd\3\2\2\2\u00e6")
        buf.write("\u00e9\3\2\2\2\u00e7\u00e5\3\2\2\2\u00e7\u00e8\3\2\2\2")
        buf.write("\u00e8\u00eb\3\2\2\2\u00e9\u00e7\3\2\2\2\u00ea\u00d6\3")
        buf.write("\2\2\2\u00eb\u00ee\3\2\2\2\u00ec\u00ea\3\2\2\2\u00ec\u00ed")
        buf.write("\3\2\2\2\u00ed\u00f1\3\2\2\2\u00ee\u00ec\3\2\2\2\u00ef")
        buf.write("\u00f1\5\34\17\2\u00f0\u00ec\3\2\2\2\u00f0\u00ef\3\2\2")
        buf.write("\2\u00f1\31\3\2\2\2\u00f2\u00f5\5\34\17\2\u00f3\u00f5")
        buf.write("\5\36\20\2\u00f4\u00f2\3\2\2\2\u00f4\u00f3\3\2\2\2\u00f5")
        buf.write("\33\3\2\2\2\u00f6\u00f7\7\t\2\2\u00f7\35\3\2\2\2\u00f8")
        buf.write("\u00f9\t\2\2\2\u00f9\37\3\2\2\2\u00fa\u00fb\t\3\2\2\u00fb")
        buf.write("!\3\2\2\2\"&+\60\66=DKRY_dj\177\u0086\u008d\u0090\u009d")
        buf.write("\u00a4\u00ae\u00b5\u00bb\u00c0\u00c3\u00cc\u00d1\u00d4")
        buf.write("\u00da\u00e1\u00e7\u00ec\u00f0\u00f4")
        return buf.getvalue()


class CoDalogParser ( Parser ):

    grammarFileName = "CoDalog.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'=='", "'!='", "'<'", "'>'", "'>='", 
                     "'<='", "<INVALID>", "<INVALID>", "'?-'", "':-'", "')'", 
                     "'('", "','", "'.'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "UW", "LW", 
                      "GOALSIGN", "RULESIGN", "RIGHTBRAK", "LEFTBRAK", "COMMA", 
                      "PERIOD", "LC", "UC", "DIGIT", "NEWLINE", "WS" ]

    RULE_prog = 0
    RULE_clause = 1
    RULE_e_rule = 2
    RULE_fact = 3
    RULE_goal = 4
    RULE_body = 5
    RULE_predicate = 6
    RULE_atom = 7
    RULE_bp = 8
    RULE_termList = 9
    RULE_constantList = 10
    RULE_variableList = 11
    RULE_term = 12
    RULE_variable = 13
    RULE_constant = 14
    RULE_op = 15

    ruleNames =  [ "prog", "clause", "e_rule", "fact", "goal", "body", "predicate", 
                   "atom", "bp", "termList", "constantList", "variableList", 
                   "term", "variable", "constant", "op" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    UW=7
    LW=8
    GOALSIGN=9
    RULESIGN=10
    RIGHTBRAK=11
    LEFTBRAK=12
    COMMA=13
    PERIOD=14
    LC=15
    UC=16
    DIGIT=17
    NEWLINE=18
    WS=19

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.ClauseContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.ClauseContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.NEWLINE)
            else:
                return self.getToken(CoDalogParser.NEWLINE, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)




    def prog(self):

        localctx = CoDalogParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 39 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 32
                self.clause()
                self.state = 36
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.NEWLINE:
                    self.state = 33
                    self.match(CoDalogParser.NEWLINE)
                    self.state = 38
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 41 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==CoDalogParser.LW or _la==CoDalogParser.GOALSIGN):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def goal(self):
            return self.getTypedRuleContext(CoDalogParser.GoalContext,0)


        def fact(self):
            return self.getTypedRuleContext(CoDalogParser.FactContext,0)


        def e_rule(self):
            return self.getTypedRuleContext(CoDalogParser.E_ruleContext,0)


        def getRuleIndex(self):
            return CoDalogParser.RULE_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClause" ):
                listener.enterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClause" ):
                listener.exitClause(self)




    def clause(self):

        localctx = CoDalogParser.ClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_clause)
        try:
            self.state = 46
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 43
                self.goal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 44
                self.fact()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 45
                self.e_rule()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class E_ruleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self):
            return self.getTypedRuleContext(CoDalogParser.PredicateContext,0)


        def RULESIGN(self):
            return self.getToken(CoDalogParser.RULESIGN, 0)

        def body(self):
            return self.getTypedRuleContext(CoDalogParser.BodyContext,0)


        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def bp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.BpContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.BpContext,i)


        def getRuleIndex(self):
            return CoDalogParser.RULE_e_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterE_rule" ):
                listener.enterE_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitE_rule" ):
                listener.exitE_rule(self)




    def e_rule(self):

        localctx = CoDalogParser.E_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_e_rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 48
            self.predicate()
            self.state = 52
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.WS:
                self.state = 49
                self.match(CoDalogParser.WS)
                self.state = 54
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 55
            self.match(CoDalogParser.RULESIGN)
            self.state = 59
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 56
                    self.match(CoDalogParser.WS) 
                self.state = 61
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

            self.state = 62
            self.body()
            self.state = 66
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 63
                    self.match(CoDalogParser.WS) 
                self.state = 68
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

            self.state = 98
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.COMMA:
                self.state = 69
                self.match(CoDalogParser.COMMA)
                self.state = 73
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.WS:
                    self.state = 70
                    self.match(CoDalogParser.WS)
                    self.state = 75
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 76
                self.bp()
                self.state = 80
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 77
                        self.match(CoDalogParser.WS) 
                    self.state = 82
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                self.state = 93
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 83
                        self.match(CoDalogParser.COMMA)
                        self.state = 87
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==CoDalogParser.WS:
                            self.state = 84
                            self.match(CoDalogParser.WS)
                            self.state = 89
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 90
                        self.bp() 
                    self.state = 95
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                self.state = 100
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.WS:
                self.state = 101
                self.match(CoDalogParser.WS)
                self.state = 106
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 107
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FactContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def constantList(self):
            return self.getTypedRuleContext(CoDalogParser.ConstantListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_fact

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFact" ):
                listener.enterFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFact" ):
                listener.exitFact(self)




    def fact(self):

        localctx = CoDalogParser.FactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_fact)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.atom()
            self.state = 110
            self.constantList()
            self.state = 111
            self.match(CoDalogParser.RIGHTBRAK)
            self.state = 112
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GoalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GOALSIGN(self):
            return self.getToken(CoDalogParser.GOALSIGN, 0)

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def termList(self):
            return self.getTypedRuleContext(CoDalogParser.TermListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def PERIOD(self):
            return self.getToken(CoDalogParser.PERIOD, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_goal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoal" ):
                listener.enterGoal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoal" ):
                listener.exitGoal(self)




    def goal(self):

        localctx = CoDalogParser.GoalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_goal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(CoDalogParser.GOALSIGN)
            self.state = 115
            self.atom()
            self.state = 116
            self.termList()
            self.state = 117
            self.match(CoDalogParser.RIGHTBRAK)
            self.state = 118
            self.match(CoDalogParser.PERIOD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.PredicateContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.PredicateContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBody" ):
                listener.enterBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBody" ):
                listener.exitBody(self)




    def body(self):

        localctx = CoDalogParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.state = 142
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 120
                self.predicate()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 139
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.LW:
                    self.state = 121
                    self.predicate()
                    self.state = 125
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 122
                        self.match(CoDalogParser.WS)
                        self.state = 127
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 128
                    self.match(CoDalogParser.COMMA)
                    self.state = 132
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 129
                        self.match(CoDalogParser.WS)
                        self.state = 134
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 135
                    self.predicate()
                    self.state = 141
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CoDalogParser.AtomContext,0)


        def variableList(self):
            return self.getTypedRuleContext(CoDalogParser.VariableListContext,0)


        def RIGHTBRAK(self):
            return self.getToken(CoDalogParser.RIGHTBRAK, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)




    def predicate(self):

        localctx = CoDalogParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self.atom()
            self.state = 145
            self.variableList()
            self.state = 146
            self.match(CoDalogParser.RIGHTBRAK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LW(self):
            return self.getToken(CoDalogParser.LW, 0)

        def LEFTBRAK(self):
            return self.getToken(CoDalogParser.LEFTBRAK, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)




    def atom(self):

        localctx = CoDalogParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_atom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(CoDalogParser.LW)
            self.state = 149
            self.match(CoDalogParser.LEFTBRAK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CoDalogParser.VariableContext,0)


        def op(self):
            return self.getTypedRuleContext(CoDalogParser.OpContext,0)


        def term(self):
            return self.getTypedRuleContext(CoDalogParser.TermContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_bp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBp" ):
                listener.enterBp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBp" ):
                listener.exitBp(self)




    def bp(self):

        localctx = CoDalogParser.BpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_bp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.variable()
            self.state = 155
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.WS:
                self.state = 152
                self.match(CoDalogParser.WS)
                self.state = 157
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 158
            self.op()
            self.state = 162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CoDalogParser.WS:
                self.state = 159
                self.match(CoDalogParser.WS)
                self.state = 164
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 165
            self.term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.TermContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.TermContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_termList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermList" ):
                listener.enterTermList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermList" ):
                listener.exitTermList(self)




    def termList(self):

        localctx = CoDalogParser.TermListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_termList)
        self._la = 0 # Token type
        try:
            self.state = 193
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 167
                self.term()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 190
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CoDalogParser.UW) | (1 << CoDalogParser.LW) | (1 << CoDalogParser.DIGIT))) != 0):
                    self.state = 168
                    self.term()
                    self.state = 172
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 169
                        self.match(CoDalogParser.WS)
                        self.state = 174
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 185
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.COMMA:
                        self.state = 175
                        self.match(CoDalogParser.COMMA)
                        self.state = 179
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==CoDalogParser.WS:
                            self.state = 176
                            self.match(CoDalogParser.WS)
                            self.state = 181
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 182
                        self.term()
                        self.state = 187
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 192
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.ConstantContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.ConstantContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_constantList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantList" ):
                listener.enterConstantList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantList" ):
                listener.exitConstantList(self)




    def constantList(self):

        localctx = CoDalogParser.ConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_constantList)
        self._la = 0 # Token type
        try:
            self.state = 210
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 195
                self.constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.LW or _la==CoDalogParser.DIGIT:
                    self.state = 196
                    self.constant()
                    self.state = 202
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.COMMA:
                        self.state = 197
                        self.match(CoDalogParser.COMMA)

                        self.state = 198
                        self.match(CoDalogParser.WS)
                        self.state = 199
                        self.constant()
                        self.state = 204
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 209
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CoDalogParser.VariableContext)
            else:
                return self.getTypedRuleContext(CoDalogParser.VariableContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.WS)
            else:
                return self.getToken(CoDalogParser.WS, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CoDalogParser.COMMA)
            else:
                return self.getToken(CoDalogParser.COMMA, i)

        def getRuleIndex(self):
            return CoDalogParser.RULE_variableList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableList" ):
                listener.enterVariableList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableList" ):
                listener.exitVariableList(self)




    def variableList(self):

        localctx = CoDalogParser.VariableListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_variableList)
        self._la = 0 # Token type
        try:
            self.state = 238
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CoDalogParser.UW:
                    self.state = 212
                    self.variable()
                    self.state = 216
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.WS:
                        self.state = 213
                        self.match(CoDalogParser.WS)
                        self.state = 218
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 229
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==CoDalogParser.COMMA:
                        self.state = 219
                        self.match(CoDalogParser.COMMA)
                        self.state = 223
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==CoDalogParser.WS:
                            self.state = 220
                            self.match(CoDalogParser.WS)
                            self.state = 225
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 226
                        self.variable()
                        self.state = 231
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 236
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 237
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CoDalogParser.VariableContext,0)


        def constant(self):
            return self.getTypedRuleContext(CoDalogParser.ConstantContext,0)


        def getRuleIndex(self):
            return CoDalogParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)




    def term(self):

        localctx = CoDalogParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_term)
        try:
            self.state = 242
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CoDalogParser.UW]:
                self.enterOuterAlt(localctx, 1)
                self.state = 240
                self.variable()
                pass
            elif token in [CoDalogParser.LW, CoDalogParser.DIGIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 241
                self.constant()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UW(self):
            return self.getToken(CoDalogParser.UW, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)




    def variable(self):

        localctx = CoDalogParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self.match(CoDalogParser.UW)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LW(self):
            return self.getToken(CoDalogParser.LW, 0)

        def DIGIT(self):
            return self.getToken(CoDalogParser.DIGIT, 0)

        def getRuleIndex(self):
            return CoDalogParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = CoDalogParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            _la = self._input.LA(1)
            if not(_la==CoDalogParser.LW or _la==CoDalogParser.DIGIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CoDalogParser.RULE_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp" ):
                listener.enterOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp" ):
                listener.exitOp(self)




    def op(self):

        localctx = CoDalogParser.OpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CoDalogParser.T__0) | (1 << CoDalogParser.T__1) | (1 << CoDalogParser.T__2) | (1 << CoDalogParser.T__3) | (1 << CoDalogParser.T__4) | (1 << CoDalogParser.T__5))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





